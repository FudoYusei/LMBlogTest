---
layout: post
title: UnityRendering (三) Culling
subtitle: 剔除正面还是背面
author: LM
categories: UnityRendering
# banner:
#   # video: https://vjs.zencdn.net/v/oceans.mp4
#   #loop: true
#   #volume: 0.8
#   #start_at: 8.5
#   image: /assets/images/banners/FlipModel.png
#   opacity: 0.8
#   background: "#000"
#   height: "50vh"
#   min_height: "38vh"
#   heading_style: "font-size: 4.25em; font-weight: bold; text-decoration: underline"
#   subheading_style: "color: gold"
excerpt_image: /assets/images/UnityRendering/UnityRendering_BackfaceCulling.jpg
tags: UnityRendering
priority: 3
---

![banner](/assets/images/UnityRendering/UnityRendering_BackfaceCulling.jpg)  

Cull Back 是 Shader 中默认的设置, 用于提前剔除背面, 节省下不必要的渲染.  
<span style='color:#4cd137'>背面指的是从观察者视角看过去是背面, </span> 进一步的认定方法就是从观察者视角看过去三角形顶点的绕序, 再进一步就是观察者视角与三角形面的法向量相对, 所以, 本质上是求出三角形面的法向量. <span style='color:#4cd137'>更准确的说法是, 世界坐标系三角形面的法向量是否朝向观察者</span>  
  

---  

## What
顶点顺序, 三角形三个顶点的顺序, 很重要, 顶点顺序 A->B->C, 决定了这个面的两个基向量 $ \vec{AB} 和 \vec{AC} $. 顶点顺序是脱离左右手坐标系存在的. <span style='color:#4cd137'>世界坐标系中顶点顺序是 A->B->C, 默认情况下, 最终渲染到屏幕上的顺序也是 A->B->C</span>  
  
顶点绕序, 得到两个基向量后, 使用叉乘得到第三个基向量, 这三个基向量组成的空间并没有偏手性, 需要我们人为赋予偏手性.  
例如, A(0,0,0) B(1, 0, 0) C(0, 1, 0), 叉乘得到的第三个基向量就是 (0, 0, 1). 看上去就是标准的三个基向量, 既可以是左手坐标系, 也可以是右手坐标系. 顶点绕序和左右手坐标系相关  

正反面, 基于观察者视角判断正反面, 已知顶点顺序和观察者位置. 如果面的法向量指向观察者, 则表示正面. 使用叉乘得到法向量, 叉乘符合空间偏手性. <span style='color:#4cd137'>叉乘本质上是数字与基向量的混合运算</span>  

偏手性改变时, 不仅需要改变对应坐标, 还需要逆转顶点顺序. 但是数学计算并没有逆转顶点顺序.  

顶点的空间变换, 实际上是求顶点在不同空间中的坐标. 例如 在 $ \vec{i} \vec{j} \vec{k} $ 基向量空间中, 三个顶点坐标 A(0,0,0) B(1, 0, 0) C(0, 1, 0). 那么在另一个基向量空间 $ 2\vec{i}, -\vec{j}, \vec{k} $ 三个顶点的坐标分别为 $ A^{'}(0, 0, 0) B^{'}(1/2, 0, 0) C^{'}(0, -1, 0) $   

如果将基向量 $ \vec{i} \vec{j} \vec{k} $ 当作左手坐标系, 那么基向量 $ \vec{i} \vec{j} -\vec{k} $ 就是右手坐标系.  

为什么偏手性改变, 会导致叉乘的结果改变. 所谓的偏手性改变, 本质上基向量以及基向量运算规则改变, 叉乘的结果省略了基向量, 加上基向量就容易理解了.  

<span style='color:#4cd137'>只靠顶点坐标在不同偏手性的坐标系叉乘计算, 缺少基向量, 并不能得到正确的向量.</span>  

---

## When
什么时候会执行背面剔除操作呢?   
Vertex Shader 中不可能, 因为此时的顶点数据是独立的. 等待 Vertex Shader 处理完毕后会进入图元装配阶段, 将独立的顶点按照图元设置组装成三角形, 这时候就形成了后序渲染的基础图元单位.  

既然要节省不必要的渲染, 那么肯定是在片元渲染之前, 因为一个三角形面会产生大量的片元, 每剔除一个三角面, 就节省了大量不必要的片元渲染.  

---

## How
常见的说法是通过向量叉乘结果判断顶点绕序.  
<span style='color:#4cd137'>这个说法少了很多关键点:</span>  
1. 观察者位置, 必需首先固定观察者的位置.
2. 必需确定左右手坐标系

通过叉乘得到三角形面的法向量, 再将法向量与观察者朝向对比.  
$$ \vec{AB} \times \vec{AC} \cdot \vec{view} $$  

而在 vertex shader 中各个空间的手性都不是固定的. 例如 Unity3D 世界坐标系是左手, ViewSpace 是右手, ClipSpace 又变成左手.   

举例说明, 左手坐标系的三个点 A (0, 0, 0) B (0, 1, 0) C(1, 0, 0), 观察者位于 (0, 0, -1), 观察者朝向向量为 view (0, 0, 1) , 计算得到 -1, 表示面的法向量朝向观察者.  
现在三个点转换为右手坐标系, z 轴反转, ABC 三个点没变, 观察者在右手坐标系中 (0, 0, 1), 朝向向量为 view (0, 0, -1), 计算得到 1, 结果却不同了.  
因为叉乘得到的结果是基于基向量的, 不同坐标系中虽然数值相同, 但是省略的基向量不同.  


<span style='color:#4cd137'>但是最终影响我们能看到一个三角面的因素只有世界坐标系中, 观察者与面的关系</span>  

举例来说, 在 Unity3D 中, 无论观察者处于什么位置, 只要从观察者位置看向三角面, 三角面是顺时针, 就说明这个面是正面. 因为 Unity3D 的世界坐标系是左手坐标系, 顺时针说明此时三角形面的法向量指向观察者.  
计算观察者朝向向量方向与三角形面的法向量夹角大于九十度.  

---  

## Why
<span style='color:#fbc531'>左右手坐标系会影响法向量方向?顶点绕序会影响法向量方向?</span> 是的, 两者缺一不可.  
一个三角形面是否正反面, 实际上是在观察者视角看过去该面的法向量朝向观察者. 法向量由顶点绕序与坐标系手性共同决定, 也就是说:  
1. 从观察者视角看过去, 如果这个面是正面, 那么这个面的法向量朝向观察者, 那么只有两种可能
   1. 顶点绕序为逆时针, 面处于右手坐标系
   2. 顶点绕序为顺时针, 面处于左手坐标系
2. 从观察者视角看过去, 如果这个面是反面, 那么这个面的法向量朝向观察者, 那么只有两种可能
   1. 顶点绕序为逆时针, 面处于左手坐标系
   2. 顶点绕序为顺时针, 面处于右手坐标系

<span style='color:#4cd137'>顶点绕序的实质是什么?</span> 顶点绕序实质是该三角面可以组成的空间的前两个基向量轴, 可以类比于 xy 轴, 因为叉乘有顺序, 顶点绕序 A->B->C, 就可以得到 x 轴 AB, y 轴 AC. 通过 AB x AC 得到第三个轴, 但是缺失了第三个轴的正方向, 这就是偏手性起作用的地方.  

<span style='color:#4cd137'>坐标系手性, 顶点绕序与正面绕序这三个东西互相关联, 只要知道其中两个就可以推出剩下的一个.</span>  
知道顶点绕序等于知道了 x 轴和 y轴以及它们叉乘的顺序, 但是无法确定第三个轴的方向, <span style='color:#4cd137'>还需要知道手性, 即左右手坐标系确定第三个轴的方向.</span>  

当对屏幕三角形进行 Cull 操作时, 此时已经知道顶点绕序, 想要计算得到面的法向量方向, 还需要知道面所处的坐标系手性.  
所以, 需要通过设置 Front Face CCW 或者 CW, 等同于告知偏手性. 这也是为什么 OpenGL 默认 CCW, DirectX 默认 CW, 因为 OpenGL 默认在世界坐标系使用右手坐标系, 而 DirectX 默认使用左手坐标系.  
<span style='color:#4cd137'>虽然 Unity3D 采用 OpenGL 渲染风格, 但是世界坐标系使用的是左手坐标系, 所以正绕序依然是顺时针</span>  

---  

## 屏幕坐标系
<span style='color:#fbc531'>已知三个顶点坐标, 观察者处于 +Z, 能够得出这三个顶点绕序是顺时针还是逆时针吗?</span>  
实际上并不能, 只能通过叉乘计算得到这三个顶点坐标绕序是坐标系的正方向还是反方向.  

<span style='color:#4cd137'>那么只要我们能够确定三个顶点所处坐标空间的手性, 就能直到顶点绕序是顺时针还是逆时针了.</span>  
在渲染流程中, 顶点最后一次空间转换就是通过 viewport 矩阵从 NDC 转换为 屏幕坐标系. 屏幕坐标系的手性和 Viewport 矩阵相关  

<span style='color:#e84118'>屏幕坐标系并不是 2D 平面, 2D 平面也无法计算法向量.</span>  
<span style='color:#4cd137'>之所以使用顶点绕序的顺逆时针来判断正反面, 是因为空间矩阵转换并不会改变顶点顺序, 并且因为渲染结果要还原观察者视角的画面, 顶点默认不会上下左右翻转.</span>  



---  

## 顶点绕序
顶点绕序只有两种: 顺时针和逆时针. <span style='color:#4cd137'>当我们使用顶点绕序的时候, 有一个隐含前提: 顶点绕序是基于观察者方向的. 而且顶点绕序一定是和正反面结合起来使用.</span> 顶点绕序确定了两个基向量叉乘的顺序, 正反面加上观察者位置去确定了第三个向量方向. 三个向量就可以计算出相对于当前坐标系的偏手性.  

在标准渲染流程中, 需要设置 FrontFace 是逆时针还是顺时针. 因为在进入光栅化之前, 会有一个 Cuilling 操作, 剔除掉不需要的面, 屏幕坐标系中需要判断三角形面是否正面.  
已知条件:  
1. 观察者位置固定, 三角形面的向量指向观察者方向即正面.   
2. 屏幕坐标系固定, Unity3D 和 OpenGL 原点处于左下方, x 轴正方向向右, y 轴正方向向上, 加上观察者位置 +Z 朝外, 组成一个右手坐标系.
3. 顶点以及顶点顺序也是已知的, 两个基向量和叉乘的顺序. 

<span style='color:#4cd137'>现在, 屏幕三角形两个基向量叉乘使用的是屏幕坐标系的规则, 而我们想要的是世界坐标系的规则.</span> 世界坐标系中的三角形面的法向量是否指向观察者.  
缺少偏手性, 因为渲染的是世界坐标系中的面, 所以在渲染流程中偏手性指的就是世界坐标系相对于屏幕坐标系的偏手性. 而屏幕坐标系并不确定, 例如 DirectX 使用左手坐标系, Unity3D 和 OpenGL 使用右手坐标系. 设置偏手性还得搞清楚不同的系统使用什么坐标系.  

解决偏手性不明的麻烦, 统一使用标准<span style='color:#4cd137'>顶点绕序</span>, 顺时针代表左手坐标系, 逆时针代表右手坐标系. 设置了世界坐标系的顶点绕序后, Cuilling 阶段就可以得知世界坐标系的偏手性, 然后根据自身偏手性计算出正反面.  

渲染管线中需要设置 FrontFace CCW 或者 FrontFace CW. 通过 RenderDoc 可以查看渲染管线设置, 能够看到 Culling 和 FrontFace 设置.  

---  

## 正反面与顶点绕序
<span style='color:#fbc531'>1. 为什么屏幕坐标系只有 xy 值也能判断旋转方向?</span>  
因为在屏幕坐标系中, z 值不影响正反面, z 值最多影响面朝向左右, 不能影响正反面, 因此 z 值可以直接取 0, 也就是只需要计算 xy 值.  

<span style='color:#fbc531'>2. 知道三角形面的两个向量顺序, 进行叉乘能得到法向量方向吗?</span>  
并不能得到法向量方向, 只有知道两个向量所处的手性, 才能明确方向. 因此, 只有知道世界坐标系手性, 才能知道三角形面在世界坐标系的叉乘方向  

<span style='color:#fbc531'>3. 三角形面最终处于屏幕坐标系吗? </span>  
NDC 通过 viewport 矩阵转换到屏幕坐标系. <span style='color:#4cd137'>但是屏幕坐标系与 viewport 矩阵的 z 轴无关.</span> 所以屏幕坐标系等于只转换了 xy 值, z 值可以视为 0, 不影响正反面判断. 屏幕三角形叉乘就必需遵守屏幕坐标系规则(手性).  

整体步骤如下:  
1. 屏幕坐标系的操作. 屏幕坐标系的 +Z 是指向屏幕向外的. 因为屏幕坐标系 xy 轴正方向都是预先定义不会改变的, 因此屏幕坐标系的手性是已知的, 所以屏幕坐标系旋转正方向已知. 
2. 因为 z 值不会改变正反面, 所以可以从顶点的 xy 值求出屏幕三角形法向量(并不是真正的法向量), 根据法向量与 +Z 的相对方向, 可以得出三角形三个顶点绕序是顺时针还是逆时针.  
3. 默认渲染流程中, 不会改变三角形顶点绕序, 世界坐标系的三角形相对于观察者来说顶点绕序没有改变. 世界坐标中, 三角形两个轴加上指向观察者的向量组成了一个向量空间.
4. 两个轴的叉积与观察者方向相同, 则为正面. 很容易就能得出, 左手坐标系时, 观察者方向看到的顶点绕序是顺时针, 右手坐标系时, 观察者方向看到的顶点绕序是逆时针.
5. 因此, 世界坐标系是左手坐标系时, 设置 FrontFace 为顺时针, 右手坐标系设置 FrontFace 为逆时针, 屏幕空间计算得到三角形的顶点绕序, 继而得出正反面.

<span style='color:#4cd137'>核心点在于: </span>  
1. 默认渲染流程中, 世界坐标系中观察者观察到的顶点绕序与屏幕坐标系中顶点绕序相同
2. 屏幕坐标系预先设置好了, 手性固定, 可以计算获得顶点绕序
3. 从观察者视角看过去, 这个条件已经隐含了 z 轴正方向.

> Unity3D 的渲染流程顶点绕序被改变, 因此 FrontFace 也被改变.

假设世界坐标系中存在一个三角形面三个顶点 OAB, 顶点顺序 O->A->B, 观察者处于 V 处, 那么从 V 处观察三角形面为正面, 说明:  
+ 三角形面的法向量 OA x OB 与 OV 同向
+ OA OB OV 三者组成的向量空间偏手性与世界坐标系偏手性一致

三个顶点坐标为 O (0, 0, 0) A(1, 0, 0) B (0, 1, 0) , 观察者 V 坐标 (0, 0 ,1)  




---  

## 总结 
<span style='color:#4cd137'>个人猜测, 背面剔除发生在剪裁之后, 光栅化之前, 顶点被装配成屏幕三角形之后.</span>    
此时, 观察者位置固定在屏幕坐标系 +Z 方向, 屏幕三角形的法向量朝向屏幕向外即正面.  

<span style='color:#4cd137'>世界坐标系中物体被渲染到屏幕上, 预期物体的性质不会发生变化, 面的法向量方向, 面的绕序都不需要发生改变, (当然实际上因为坐标系变换, 这些都会发生变换). 因此坐标系变化都不会影响面的绕序.</span> 因为预期渲染结果就是, 世界坐标系什么样, 渲染出来就是什么样.  
世界坐标系是左手坐标系, 那么 FrontFace 就设置为 CW(顺时针), 世界坐标系是右手坐标系, 那么 FrontFace 就设置为 CCW(逆时针)  

<span style='color:#fbc531'> View Space 的左右手性影响正反判断吗?</span> 不影响, 绕序是顶点之间的相对位置, 只要顶点相对位置不变, 在哪个坐标系绕序都是相同的. 而实际上, 当偏手性转变的时候, 顶点绕序是应该跟随改变的, 如果不改变需要记录相对偏手性  
  
在屏幕坐标系中, 观察者固定在 +Z 方向上, Unity3D 和 OpenGL 屏幕坐标系原点在左下角, 屏幕坐标系形成一个右手坐标系, DirectX 屏幕坐标系原点在左上角, 屏幕坐标系形成一个左手坐标系. <span style='color:#4cd137'>但是我们并不需要关注屏幕坐标系的偏手性, 只需要根据世界坐标系的偏手性设置正面顶点绕序, 左手坐标系对应顺时针, 右手坐标系对应逆时针</span>  
  
1. 屏幕坐标系手性固定, 